1.

Сначала задаётся так называемое "зерно" - это некое число, которое берётся из разных источников - например время системы. 
Затем зерно используется генератором равномерно распределённых значений. А дальше уже эти значения идут в необходимую функцию распределения, которая выдаёт уже финальные числа

2.

У них иначе реализуются состояния - с помощью данных-членов, 
имеется свой тип - даже при одинаковом содержании их можно различать, 
и их можно передавать в качестве аргумента как простые данные, а не как функцию, что быстрее

3.

1) Input_Iterator имеют операции : != , == , ++, =, *, -> (чтение) // например, instream_iterator и outstream_iterator - итераторы потока
2) Output_Iterator != , == , ++, =, *, -> (запись)
3) Forward_Iterator : имеет операции прошлых + многопроходность // в forward_list, например
4) Bidirectional_Iterator : прошлые + -- // например, list, set
5) Random_Access_Iterator : прошлые + in, <, > // vector, deque

4.

1) Немодифицирующие - которые не модифицируют последовательность
2) Модифицирущие - которые модифицируют последовательность)
2.1) Алгоритмы удаления - удаление определённых элементов из последовательности (не из контейнера!)
2.2) Алгоритмы вставки
2.3) Алгоритмы перестановки
2.4) Алгоритмы сортировки
2.5) Алгоритмы для упорядоченных диапазонов
2.6) Численные алгоритмы

5.

Они безопасные, в меру эффективные, есть на всех системах, так что программа будет работать везде. С ними просто удобнее писать код - не надо самому всегда заново писать.
И нельзя забывать о тех, кто будет код читать - с ними намного понятнее, т.к. они стандартные, т.е. используются везде, а унифицированный код = понятный всем